// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
  non_camel_case_types,
  unused,
  non_snake_case,
  clippy::needless_return,
  clippy::redundant_closure_call,
  clippy::redundant_closure,
  clippy::useless_conversion,
  clippy::unit_arg,
  clippy::unused_unit,
  clippy::double_parens,
  clippy::let_and_return,
  clippy::too_many_arguments,
  clippy::match_single_binding,
  clippy::clone_on_copy,
  clippy::let_unit_value,
  clippy::deref_addrof,
  clippy::explicit_auto_deref,
  clippy::borrow_deref_ref,
  clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{
  NativeEndian, ReadBytesExt, WriteBytesExt,
};
use flutter_rust_bridge::for_generated::{
  transform_result_dco, Lifetimeable, Lockable,
};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
  default_stream_sink_codec = SseCodec,
  default_rust_opaque = RustOpaqueMoi,
  default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 823394672;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__soft_metatags__init_app_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER
    .wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
      flutter_rust_bridge::for_generated::TaskInfo {
        debug_name: "init_app",
        port: Some(port_),
        mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
      },
      move || {
        let message = unsafe {
          flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
            ptr_,
            rust_vec_len_,
            data_len_,
          )
        };
        let mut deserializer =
          flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        deserializer.end();
        move |context| {
          transform_result_sse::<_, ()>((move || {
            let output_ok = Result::<_, ()>::Ok({
              crate::api::soft_metatags::init_app();
            })?;
            Ok(output_ok)
          })())
        }
      },
    )
}
fn wire__crate__api__soft_metatags__read_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER
    .wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
      flutter_rust_bridge::for_generated::TaskInfo {
        debug_name: "read",
        port: Some(port_),
        mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
      },
      move || {
        let message = unsafe {
          flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
            ptr_,
            rust_vec_len_,
            data_len_,
          )
        };
        let mut deserializer =
          flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let api_path = <String>::sse_decode(&mut deserializer);
        deserializer.end();
        move |context| {
          transform_result_sse::<_, ()>((move || {
            let output_ok =
              Result::<_, ()>::Ok(crate::api::soft_metatags::read(&api_path))?;
            Ok(output_ok)
          })())
        }
      },
    )
}

// Section: dart2rust

impl SseDecode for String {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    let mut inner = <Vec<u8>>::sse_decode(deserializer);
    return String::from_utf8(inner).unwrap();
  }
}

impl SseDecode for crate::api::entities::album::Album {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    let mut var_title = <Option<String>>::sse_decode(deserializer);
    let mut var_artwork = <Option<Vec<u8>>>::sse_decode(deserializer);
    let mut var_artists =
      <Option<Vec<crate::api::entities::artist::Artist>>>::sse_decode(
        deserializer,
      );
    return crate::api::entities::album::Album {
      title: var_title,
      artwork: var_artwork,
      artists: var_artists,
    };
  }
}

impl SseDecode for crate::api::entities::artist::Artist {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    let mut var_name = <Option<String>>::sse_decode(deserializer);
    let mut var_picture = <Option<Vec<u8>>>::sse_decode(deserializer);
    return crate::api::entities::artist::Artist {
      name: var_name,
      picture: var_picture,
    };
  }
}

impl SseDecode for crate::api::entities::disc::Disc {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    let mut var_total = <Option<u32>>::sse_decode(deserializer);
    let mut var_number = <Option<u32>>::sse_decode(deserializer);
    return crate::api::entities::disc::Disc {
      total: var_total,
      number: var_number,
    };
  }
}

impl SseDecode for crate::api::entities::genre::Genre {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    let mut var_name = <Option<String>>::sse_decode(deserializer);
    return crate::api::entities::genre::Genre { name: var_name };
  }
}

impl SseDecode for Vec<crate::api::entities::album::Album> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    let mut len_ = <i32>::sse_decode(deserializer);
    let mut ans_ = vec![];
    for idx_ in 0..len_ {
      ans_.push(<crate::api::entities::album::Album>::sse_decode(
        deserializer,
      ));
    }
    return ans_;
  }
}

impl SseDecode for Vec<crate::api::entities::artist::Artist> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    let mut len_ = <i32>::sse_decode(deserializer);
    let mut ans_ = vec![];
    for idx_ in 0..len_ {
      ans_.push(<crate::api::entities::artist::Artist>::sse_decode(
        deserializer,
      ));
    }
    return ans_;
  }
}

impl SseDecode for Vec<crate::api::entities::genre::Genre> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    let mut len_ = <i32>::sse_decode(deserializer);
    let mut ans_ = vec![];
    for idx_ in 0..len_ {
      ans_.push(<crate::api::entities::genre::Genre>::sse_decode(
        deserializer,
      ));
    }
    return ans_;
  }
}

impl SseDecode for Vec<u8> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    let mut len_ = <i32>::sse_decode(deserializer);
    let mut ans_ = vec![];
    for idx_ in 0..len_ {
      ans_.push(<u8>::sse_decode(deserializer));
    }
    return ans_;
  }
}

impl SseDecode for crate::api::entities::meta::Meta {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    let mut var_bpm = <Option<u32>>::sse_decode(deserializer);
    let mut var_year = <Option<u32>>::sse_decode(deserializer);
    let mut var_date = <Option<u32>>::sse_decode(deserializer);
    let mut var_disc =
      <Option<crate::api::entities::disc::Disc>>::sse_decode(deserializer);
    let mut var_track =
      <Option<crate::api::entities::track::Track>>::sse_decode(deserializer);
    let mut var_isrc = <Option<String>>::sse_decode(deserializer);
    let mut var_mood = <Option<String>>::sse_decode(deserializer);
    let mut var_title = <Option<String>>::sse_decode(deserializer);
    let mut var_label = <Option<String>>::sse_decode(deserializer);
    let mut var_lyrics = <Option<String>>::sse_decode(deserializer);
    let mut var_comment = <Option<String>>::sse_decode(deserializer);
    let mut var_barcode = <Option<String>>::sse_decode(deserializer);
    let mut var_composer = <Option<String>>::sse_decode(deserializer);
    let mut var_lyricist = <Option<String>>::sse_decode(deserializer);
    let mut var_performer = <Option<String>>::sse_decode(deserializer);
    let mut var_conductor = <Option<String>>::sse_decode(deserializer);
    let mut var_copyright = <Option<String>>::sse_decode(deserializer);
    let mut var_albums =
      <Option<Vec<crate::api::entities::album::Album>>>::sse_decode(
        deserializer,
      );
    let mut var_genres =
      <Option<Vec<crate::api::entities::genre::Genre>>>::sse_decode(
        deserializer,
      );
    let mut var_encodedBy = <Option<String>>::sse_decode(deserializer);
    let mut var_catalogNumber = <Option<u32>>::sse_decode(deserializer);
    let mut var_artists =
      <Option<Vec<crate::api::entities::artist::Artist>>>::sse_decode(
        deserializer,
      );
    return crate::api::entities::meta::Meta {
      bpm: var_bpm,
      year: var_year,
      date: var_date,
      disc: var_disc,
      track: var_track,
      isrc: var_isrc,
      mood: var_mood,
      title: var_title,
      label: var_label,
      lyrics: var_lyrics,
      comment: var_comment,
      barcode: var_barcode,
      composer: var_composer,
      lyricist: var_lyricist,
      performer: var_performer,
      conductor: var_conductor,
      copyright: var_copyright,
      albums: var_albums,
      genres: var_genres,
      encoded_by: var_encodedBy,
      catalog_number: var_catalogNumber,
      artists: var_artists,
    };
  }
}

impl SseDecode for Option<String> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<String>::sse_decode(deserializer));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<crate::api::entities::disc::Disc> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<crate::api::entities::disc::Disc>::sse_decode(
        deserializer,
      ));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<crate::api::entities::meta::Meta> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<crate::api::entities::meta::Meta>::sse_decode(
        deserializer,
      ));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<crate::api::entities::song::Song> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<crate::api::entities::song::Song>::sse_decode(
        deserializer,
      ));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<crate::api::entities::track::Track> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<crate::api::entities::track::Track>::sse_decode(
        deserializer,
      ));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<u32> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<u32>::sse_decode(deserializer));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<Vec<crate::api::entities::album::Album>> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<Vec<crate::api::entities::album::Album>>::sse_decode(
        deserializer,
      ));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<Vec<crate::api::entities::artist::Artist>> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<Vec<crate::api::entities::artist::Artist>>::sse_decode(
        deserializer,
      ));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<Vec<crate::api::entities::genre::Genre>> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<Vec<crate::api::entities::genre::Genre>>::sse_decode(
        deserializer,
      ));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<Vec<u8>> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<Vec<u8>>::sse_decode(deserializer));
    } else {
      return None;
    }
  }
}

impl SseDecode for crate::api::entities::song::Song {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    let mut var_path = <String>::sse_decode(deserializer);
    let mut var_title = <String>::sse_decode(deserializer);
    let mut var_duration = <u64>::sse_decode(deserializer);
    let mut var_meta =
      <Option<crate::api::entities::meta::Meta>>::sse_decode(deserializer);
    return crate::api::entities::song::Song {
      path: var_path,
      title: var_title,
      duration: var_duration,
      meta: var_meta,
    };
  }
}

impl SseDecode for crate::api::entities::track::Track {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    let mut var_total = <Option<u32>>::sse_decode(deserializer);
    let mut var_number = <Option<u32>>::sse_decode(deserializer);
    return crate::api::entities::track::Track {
      total: var_total,
      number: var_number,
    };
  }
}

impl SseDecode for u32 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    deserializer.cursor.read_u32::<NativeEndian>().unwrap()
  }
}

impl SseDecode for u64 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    deserializer.cursor.read_u64::<NativeEndian>().unwrap()
  }
}

impl SseDecode for u8 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    deserializer.cursor.read_u8().unwrap()
  }
}

impl SseDecode for () {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
  }
}

impl SseDecode for i32 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    deserializer.cursor.read_i32::<NativeEndian>().unwrap()
  }
}

impl SseDecode for bool {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(
    deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
  ) -> Self {
    deserializer.cursor.read_u8().unwrap() != 0
  }
}

fn pde_ffi_dispatcher_primary_impl(
  func_id: i32,
  port: flutter_rust_bridge::for_generated::MessagePort,
  ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len: i32,
  data_len: i32,
) {
  // Codec=Pde (Serialization + dispatch), see doc to use other codecs
  match func_id {
    1 => wire__crate__api__soft_metatags__init_app_impl(
      port,
      ptr,
      rust_vec_len,
      data_len,
    ),
    2 => wire__crate__api__soft_metatags__read_impl(
      port,
      ptr,
      rust_vec_len,
      data_len,
    ),
    _ => unreachable!(),
  }
}

fn pde_ffi_dispatcher_sync_impl(
  func_id: i32,
  ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len: i32,
  data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
  // Codec=Pde (Serialization + dispatch), see doc to use other codecs
  match func_id {
    _ => unreachable!(),
  }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::entities::album::Album {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [
      self.title.into_into_dart().into_dart(),
      self.artwork.into_into_dart().into_dart(),
      self.artists.into_into_dart().into_dart(),
    ]
    .into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for crate::api::entities::album::Album
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::entities::album::Album>
  for crate::api::entities::album::Album
{
  fn into_into_dart(self) -> crate::api::entities::album::Album {
    self
  }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::entities::artist::Artist {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [
      self.name.into_into_dart().into_dart(),
      self.picture.into_into_dart().into_dart(),
    ]
    .into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for crate::api::entities::artist::Artist
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::entities::artist::Artist>
  for crate::api::entities::artist::Artist
{
  fn into_into_dart(self) -> crate::api::entities::artist::Artist {
    self
  }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::entities::disc::Disc {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [
      self.total.into_into_dart().into_dart(),
      self.number.into_into_dart().into_dart(),
    ]
    .into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for crate::api::entities::disc::Disc
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::entities::disc::Disc>
  for crate::api::entities::disc::Disc
{
  fn into_into_dart(self) -> crate::api::entities::disc::Disc {
    self
  }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::entities::genre::Genre {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [self.name.into_into_dart().into_dart()].into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for crate::api::entities::genre::Genre
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::entities::genre::Genre>
  for crate::api::entities::genre::Genre
{
  fn into_into_dart(self) -> crate::api::entities::genre::Genre {
    self
  }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::entities::meta::Meta {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [
      self.bpm.into_into_dart().into_dart(),
      self.year.into_into_dart().into_dart(),
      self.date.into_into_dart().into_dart(),
      self.disc.into_into_dart().into_dart(),
      self.track.into_into_dart().into_dart(),
      self.isrc.into_into_dart().into_dart(),
      self.mood.into_into_dart().into_dart(),
      self.title.into_into_dart().into_dart(),
      self.label.into_into_dart().into_dart(),
      self.lyrics.into_into_dart().into_dart(),
      self.comment.into_into_dart().into_dart(),
      self.barcode.into_into_dart().into_dart(),
      self.composer.into_into_dart().into_dart(),
      self.lyricist.into_into_dart().into_dart(),
      self.performer.into_into_dart().into_dart(),
      self.conductor.into_into_dart().into_dart(),
      self.copyright.into_into_dart().into_dart(),
      self.albums.into_into_dart().into_dart(),
      self.genres.into_into_dart().into_dart(),
      self.encoded_by.into_into_dart().into_dart(),
      self.catalog_number.into_into_dart().into_dart(),
      self.artists.into_into_dart().into_dart(),
    ]
    .into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for crate::api::entities::meta::Meta
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::entities::meta::Meta>
  for crate::api::entities::meta::Meta
{
  fn into_into_dart(self) -> crate::api::entities::meta::Meta {
    self
  }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::entities::song::Song {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [
      self.path.into_into_dart().into_dart(),
      self.title.into_into_dart().into_dart(),
      self.duration.into_into_dart().into_dart(),
      self.meta.into_into_dart().into_dart(),
    ]
    .into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for crate::api::entities::song::Song
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::entities::song::Song>
  for crate::api::entities::song::Song
{
  fn into_into_dart(self) -> crate::api::entities::song::Song {
    self
  }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::entities::track::Track {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [
      self.total.into_into_dart().into_dart(),
      self.number.into_into_dart().into_dart(),
    ]
    .into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for crate::api::entities::track::Track
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::entities::track::Track>
  for crate::api::entities::track::Track
{
  fn into_into_dart(self) -> crate::api::entities::track::Track {
    self
  }
}

impl SseEncode for String {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
  }
}

impl SseEncode for crate::api::entities::album::Album {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <Option<String>>::sse_encode(self.title, serializer);
    <Option<Vec<u8>>>::sse_encode(self.artwork, serializer);
    <Option<Vec<crate::api::entities::artist::Artist>>>::sse_encode(
      self.artists,
      serializer,
    );
  }
}

impl SseEncode for crate::api::entities::artist::Artist {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <Option<String>>::sse_encode(self.name, serializer);
    <Option<Vec<u8>>>::sse_encode(self.picture, serializer);
  }
}

impl SseEncode for crate::api::entities::disc::Disc {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <Option<u32>>::sse_encode(self.total, serializer);
    <Option<u32>>::sse_encode(self.number, serializer);
  }
}

impl SseEncode for crate::api::entities::genre::Genre {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <Option<String>>::sse_encode(self.name, serializer);
  }
}

impl SseEncode for Vec<crate::api::entities::album::Album> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <i32>::sse_encode(self.len() as _, serializer);
    for item in self {
      <crate::api::entities::album::Album>::sse_encode(item, serializer);
    }
  }
}

impl SseEncode for Vec<crate::api::entities::artist::Artist> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <i32>::sse_encode(self.len() as _, serializer);
    for item in self {
      <crate::api::entities::artist::Artist>::sse_encode(item, serializer);
    }
  }
}

impl SseEncode for Vec<crate::api::entities::genre::Genre> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <i32>::sse_encode(self.len() as _, serializer);
    for item in self {
      <crate::api::entities::genre::Genre>::sse_encode(item, serializer);
    }
  }
}

impl SseEncode for Vec<u8> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <i32>::sse_encode(self.len() as _, serializer);
    for item in self {
      <u8>::sse_encode(item, serializer);
    }
  }
}

impl SseEncode for crate::api::entities::meta::Meta {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <Option<u32>>::sse_encode(self.bpm, serializer);
    <Option<u32>>::sse_encode(self.year, serializer);
    <Option<u32>>::sse_encode(self.date, serializer);
    <Option<crate::api::entities::disc::Disc>>::sse_encode(
      self.disc, serializer,
    );
    <Option<crate::api::entities::track::Track>>::sse_encode(
      self.track, serializer,
    );
    <Option<String>>::sse_encode(self.isrc, serializer);
    <Option<String>>::sse_encode(self.mood, serializer);
    <Option<String>>::sse_encode(self.title, serializer);
    <Option<String>>::sse_encode(self.label, serializer);
    <Option<String>>::sse_encode(self.lyrics, serializer);
    <Option<String>>::sse_encode(self.comment, serializer);
    <Option<String>>::sse_encode(self.barcode, serializer);
    <Option<String>>::sse_encode(self.composer, serializer);
    <Option<String>>::sse_encode(self.lyricist, serializer);
    <Option<String>>::sse_encode(self.performer, serializer);
    <Option<String>>::sse_encode(self.conductor, serializer);
    <Option<String>>::sse_encode(self.copyright, serializer);
    <Option<Vec<crate::api::entities::album::Album>>>::sse_encode(
      self.albums,
      serializer,
    );
    <Option<Vec<crate::api::entities::genre::Genre>>>::sse_encode(
      self.genres,
      serializer,
    );
    <Option<String>>::sse_encode(self.encoded_by, serializer);
    <Option<u32>>::sse_encode(self.catalog_number, serializer);
    <Option<Vec<crate::api::entities::artist::Artist>>>::sse_encode(
      self.artists,
      serializer,
    );
  }
}

impl SseEncode for Option<String> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <String>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for Option<crate::api::entities::disc::Disc> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <crate::api::entities::disc::Disc>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for Option<crate::api::entities::meta::Meta> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <crate::api::entities::meta::Meta>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for Option<crate::api::entities::song::Song> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <crate::api::entities::song::Song>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for Option<crate::api::entities::track::Track> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <crate::api::entities::track::Track>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for Option<u32> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <u32>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for Option<Vec<crate::api::entities::album::Album>> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <Vec<crate::api::entities::album::Album>>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for Option<Vec<crate::api::entities::artist::Artist>> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <Vec<crate::api::entities::artist::Artist>>::sse_encode(
        value, serializer,
      );
    }
  }
}

impl SseEncode for Option<Vec<crate::api::entities::genre::Genre>> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <Vec<crate::api::entities::genre::Genre>>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for Option<Vec<u8>> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <Vec<u8>>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for crate::api::entities::song::Song {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <String>::sse_encode(self.path, serializer);
    <String>::sse_encode(self.title, serializer);
    <u64>::sse_encode(self.duration, serializer);
    <Option<crate::api::entities::meta::Meta>>::sse_encode(
      self.meta, serializer,
    );
  }
}

impl SseEncode for crate::api::entities::track::Track {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    <Option<u32>>::sse_encode(self.total, serializer);
    <Option<u32>>::sse_encode(self.number, serializer);
  }
}

impl SseEncode for u32 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
  }
}

impl SseEncode for u64 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
  }
}

impl SseEncode for u8 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    serializer.cursor.write_u8(self).unwrap();
  }
}

impl SseEncode for () {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
  }
}

impl SseEncode for i32 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
  }
}

impl SseEncode for bool {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(
    self,
    serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
  ) {
    serializer.cursor.write_u8(self as _).unwrap();
  }
}

#[cfg(not(target_family = "wasm"))]
mod io {
  // This file is automatically generated, so please do not edit it.
  // @generated by `flutter_rust_bridge`@ 2.11.1.

  // Section: imports

  use super::*;
  use flutter_rust_bridge::for_generated::byteorder::{
    NativeEndian, ReadBytesExt, WriteBytesExt,
  };
  use flutter_rust_bridge::for_generated::{
    transform_result_dco, Lifetimeable, Lockable,
  };
  use flutter_rust_bridge::{Handler, IntoIntoDart};

  // Section: boilerplate

  flutter_rust_bridge::frb_generated_boilerplate_io!();
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
  // This file is automatically generated, so please do not edit it.
  // @generated by `flutter_rust_bridge`@ 2.11.1.

  // Section: imports

  use super::*;
  use flutter_rust_bridge::for_generated::byteorder::{
    NativeEndian, ReadBytesExt, WriteBytesExt,
  };
  use flutter_rust_bridge::for_generated::wasm_bindgen;
  use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
  use flutter_rust_bridge::for_generated::{
    transform_result_dco, Lifetimeable, Lockable,
  };
  use flutter_rust_bridge::{Handler, IntoIntoDart};

  // Section: boilerplate

  flutter_rust_bridge::frb_generated_boilerplate_web!();
}
#[cfg(target_family = "wasm")]
pub use web::*;
